/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f407xx.h"
#include "ds1307.h"
#include "lcd.h"
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

RTC_time_t g_rtc_time;
RTC_date_t g_rtc_date;

char message[] = "SOs Clock";

char *week[7] = { "MOND", "TUES", "WEDN", "THUR", "FRID", "SATD", "SAND"};

char lcd_line[17];

#define SYSTICK_TIM_CLK 16000000UL

void delay(void)
{
	for(uint32_t i = 0 ; i < 10000/2 ; i ++);
}
void mdelay(uint32_t cnt)
{
	for(uint32_t i=0; i <(cnt*1000); i++);
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

    /* calculation of reload value */
    uint32_t count_value = (SYSTICK_TIM_CLK/tick_hz)-1;

    //Clear the value of SVR
    *pSRVR &= ~(0x00FFFFFFFF);

    //load the value in to SVR
    *pSRVR |= count_value;

    //do some settings
    *pSCSR |= ( 1 << 1); //Enables SysTick exception request:
    *pSCSR |= ( 1 << 2);  //Indicates the clock source, processor clock source

    //enable the systick
    *pSCSR |= ( 1 << 0); //enables the counter

}

int main(void)
{
	printf("Application is started\n");

	init_systick_timer(1); // Generate Systick exception on evety 1 seconds

	lcd_init();
	lcd_print_string(message);

	mdelay(200);

	lcd_display_clear();

	// uint8_t old, new;

	if(!ds1307_init())
		printf("RCT initialization is successful!\n");

	g_rtc_time.hours = 23;
	g_rtc_time.minutes = 59;
	g_rtc_time.seconds = 44;
	g_rtc_time.time_format = DS1307_TIME_FORMAT_24HRS;

	g_rtc_date.date = 7;
	g_rtc_date.day = MONDAY;
	g_rtc_date.month = 9;
	g_rtc_date.year = 21;

	ds1307_set_current_time(&g_rtc_time);
	ds1307_set_current_date(&g_rtc_date);

	while(1)
	{
		/*
		ds1307_get_current_time(&g_rtc_time);
		ds1307_get_current_date(&g_rtc_date);
		new = g_rtc_time.seconds;

		if(old != new)
		{
			printf("Time is: %02d:%02d:%02d \t Date is: %02d/%02d/19%d\n", g_rtc_time.hours, g_rtc_time.minutes, g_rtc_time.seconds, g_rtc_date.date, g_rtc_date.month, g_rtc_date.year);
			old = new;
		}

		delay();
		*/
	}
    /* Loop forever */
	for(;;);
}

void SysTick_Handler(void)
{
	ds1307_get_current_time(&g_rtc_time);
	ds1307_get_current_date(&g_rtc_date);

	lcd_set_cursor(1, 1);
	sprintf((char *)&lcd_line, "<%s>  %02d/%02d/%02d", week[g_rtc_date.day-1], g_rtc_date.date, g_rtc_date.month, g_rtc_date.year);
	lcd_line[17] = '\0';
	lcd_print_string((char *)&lcd_line);

	lcd_set_cursor(2, 1);
	sprintf((char *)&lcd_line, "    %02d:%02d:%02d", g_rtc_time.hours, g_rtc_time.minutes, g_rtc_time.seconds);
	lcd_line[17] = '\0';
	lcd_print_string((char *)&lcd_line);
}
